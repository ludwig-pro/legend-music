diff --git a/lib/localReader.js b/lib/localReader.js
index 016a0e1f30d5518f4ae2d04c11693ae786578882..cd7de41e42f4e8e8d50ed0c4073701c6e08576d9 100755
--- a/lib/localReader.js
+++ b/lib/localReader.js
@@ -1,72 +1,83 @@
-import { Reader } from './reader.js';
-import * as fs from 'fs';
+import * as FileSystemNext from "expo-file-system/next";
+import { Reader } from "./reader.js";
+
 /**
  * Provides read access to the local file system
  */
 export class LocalReader extends Reader {
-    /**
-     * @param {string} path Path of the local file
-     */
-    constructor(path) {
-        super();
-        this._path = path;
-    }
-    /** @inheritdoc */
-    async open() {
-        return new Promise((resolve, reject) => {
-            fs.stat(this._path, (err, stat) => {
-                if (err) {
-                    reject(err);
-                    return;
-                }
-                this.size = stat.size;
-                fs.open(this._path, 'r', (openErr, fd) => {
-                    if (openErr) {
-                        reject(err);
-                        return;
-                    }
-                    this._fd = fd;
-                    resolve();
-                });
-            });
-        });
-    }
-    /** @inheritdoc */
-    async close() {
-        return new Promise((resolve, reject) => {
-            if (this._fd === undefined) {
-                reject(new Error('Resource not yet open'));
-                return;
-            }
-            fs.close(this._fd, (err) => {
-                if (err) {
-                    reject(err);
-                }
-                else {
-                    resolve();
-                }
-            });
-        });
-    }
-    /** @inheritdoc */
-    async read(length, position) {
-        const buffer = Buffer.alloc(length);
-        return new Promise((resolve, reject) => {
-            if (this._fd === undefined) {
-                reject(new Error('Resource not yet open'));
-                return;
-            }
-            fs.read(this._fd, buffer, 0, length, position, (err, _bytesRead, buffer) => {
-                if (err) {
-                    return reject(err);
-                }
-                const ab = new ArrayBuffer(buffer.length);
-                const view = new Uint8Array(ab);
-                for (let i = 0; i < buffer.length; i++) {
-                    view[i] = buffer[i];
-                }
-                resolve(ab);
-            });
-        });
-    }
+	/**
+	 * @param {string} path Path of the local file
+	 */
+	constructor(path) {
+		super();
+		this._path = path;
+		// Create FileSystemNext.File object from the path
+		// We need to split the path into directory and filename
+		const pathParts = path.split("/");
+		const filename = pathParts.pop();
+		const directoryPath = pathParts.join("/");
+
+		// Create directory and file objects
+		this._directory = new FileSystemNext.Directory(directoryPath);
+		this._file = new FileSystemNext.File(this._directory, filename);
+		this._fileHandle = null;
+	}
+
+	/** @inheritdoc */
+	async open() {
+		try {
+			if (!this._file.exists) {
+				throw new Error(`File not found: ${this._path}`);
+			}
+
+			// Open file handle for reading
+			this._fileHandle = this._file.open();
+			this.size = typeof this._fileHandle.size === "number" ? this._fileHandle.size : 0;
+		} catch (err) {
+			throw err;
+		}
+	}
+
+	/** @inheritdoc */
+	async close() {
+		if (this._fileHandle === null) {
+			throw new Error("Resource not yet open");
+		}
+
+		try {
+			this._fileHandle.close();
+			this._fileHandle = null;
+		} catch (err) {
+			throw err;
+		}
+	}
+
+	/** @inheritdoc */
+	async read(length, position) {
+		if (this._fileHandle === null) {
+			throw new Error("Resource not yet open");
+		}
+
+		try {
+			const size = typeof this._fileHandle.size === "number" ? this._fileHandle.size : 0;
+			const requestedLength = Math.max(0, length);
+			const start = Math.max(0, Math.min(position, size));
+			const available = Math.max(0, size - start);
+			const toRead = Math.min(requestedLength, available);
+
+			// Always return the requested length so the parser can safely read.
+			const output = new Uint8Array(requestedLength);
+
+			this._fileHandle.offset = start;
+			if (toRead > 0) {
+				const bytes = this._fileHandle.readBytes(toRead);
+				output.set(bytes.subarray(0, requestedLength));
+			}
+
+			return output.buffer;
+		} catch (err) {
+			// Fall back to a zeroed buffer to avoid throwing from callers that expect fixed-length reads.
+			return new ArrayBuffer(length);
+		}
+	}
 }
